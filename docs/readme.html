<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Yamp</title>
        
            <style>body {
    -ms-text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%;
    line-height: 1.5;
    color: #333;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    font-size: 16px;
    word-wrap: break-word;
    box-sizing: border-box;
    min-width: 200px;
    max-width: 980px;
    margin: 0 auto;
    padding: 45px;
}

.pl-c {
    color: #969896;
}

.pl-c1, .pl-s .pl-v {
    color: #0086b3;
}

.pl-e, .pl-en {
    color: #795da3;
}

.pl-smi, .pl-s .pl-s1 {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k {
    color: #a71d5d;
}

.pl-s, .pl-pds, .pl-s .pl-pse .pl-s1, .pl-sr, .pl-sr .pl-cce, .pl-sr .pl-sre, .pl-sr .pl-sra {
    color: #183691;
}

.pl-v {
    color: #ed6a43;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    color: #f8f8f8;
    background-color: #b52a1d;
}

.pl-sr .pl-cce {
    font-weight: bold;
    color: #63a35c;
}

.pl-ml {
    color: #693a17;
}

.pl-mh, .pl-mh .pl-en, .pl-ms {
    font-weight: bold;
    color: #1d3e81;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    font-style: italic;
    color: #333;
}

.pl-mb {
    font-weight: bold;
    color: #333;
}

.pl-md {
    color: #bd2c00;
    background-color: #ffecec;
}

.pl-mi1 {
    color: #55a532;
    background-color: #eaffea;
}

.pl-mdr {
    font-weight: bold;
    color: #795da3;
}

.pl-mo {
    color: #1d3e81;
}

a {
    background-color: transparent;
    -webkit-text-decoration-skip: objects;
}

a:active, a:hover {
    outline-width: 0;
}

strong {
    font-weight: inherit;
}

strong {
    font-weight: bolder;
}

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

img {
    border-style: none;
}

svg:not(:root) {
    overflow: hidden;
}

code, kbd, pre {
    font-family: monospace, monospace;
    font-size: 1em;
}

hr {
    box-sizing: content-box;
    height: 0;
    overflow: visible;
}

input {
    font: inherit;
    margin: 0;
}

input {
    overflow: visible;
}

button:-moz-focusring, [type="button"]:-moz-focusring, [type="reset"]:-moz-focusring, [type="submit"]:-moz-focusring {
    outline: 1px dotted ButtonText;
}

[type="checkbox"] {
    box-sizing: border-box;
    padding: 0;
}

* {
    box-sizing: border-box;
}

input {
    font-family: inherit;
    font-size: inherit;
    line-height: inherit;
}

a {
    color: #4078c0;
    text-decoration: none;
}

a:hover, a:active {
    text-decoration: underline;
}

strong {
    font-weight: 600;
}

hr {
    height: 0;
    margin: 15px 0;
    overflow: hidden;
    background: transparent;
    border: 0;
    border-bottom: 1px solid #ddd;
}

hr::before {
    display: table;
    content: "";
}

hr::after {
    display: table;
    clear: both;
    content: "";
}

table {
    border-spacing: 0;
    border-collapse: collapse;
}

td, th {
    padding: 0;
}

h1, h2, h3, h4, h5, h6 {
    margin-top: 0;
    margin-bottom: 0;
}

h1 {
    font-size: 32px;
    font-weight: 600;
}

h2 {
    font-size: 24px;
    font-weight: 600;
}

h3 {
    font-size: 20px;
    font-weight: 600;
}

h4 {
    font-size: 16px;
    font-weight: 600;
}

h5 {
    font-size: 14px;
    font-weight: 600;
}

h6 {
    font-size: 12px;
    font-weight: 600;
}

p {
    margin-top: 0;
    margin-bottom: 10px;
}

blockquote {
    margin: 0;
}

ul, ol {
    padding-left: 0;
    margin-top: 0;
    margin-bottom: 0;
}

ol ol, ul ol {
    list-style-type: lower-roman;
}

ul ul ol, ul ol ol, ol ul ol, ol ol ol {
    list-style-type: lower-alpha;
}

dd {
    margin-left: 0;
}

code {
    font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
    font-size: 12px;
}

pre {
    margin-top: 0;
    margin-bottom: 0;
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.octicon {
    vertical-align: text-bottom;
}

input {
    -webkit-font-feature-settings: "liga" 0;
    font-feature-settings: "liga" 0;
}

.form-select::-ms-expand {
    opacity: 0;
}

.markdown-body::before {
    display: table;
    content: "";
}

.markdown-body::after {
    display: table;
    clear: both;
    content: "";
}

.markdown-body>*:first-child {
    margin-top: 0 !important;
}

.markdown-body>*:last-child {
    margin-bottom: 0 !important;
}

a:not([href]) {
    color: inherit;
    text-decoration: none;
}

.anchor {
    float: left;
    padding-right: 4px;
    margin-left: -20px;
    line-height: 1;
}

.anchor:focus {
    outline: none;
}

p, blockquote, ul, ol, dl, table, pre {
    margin-top: 0;
    margin-bottom: 16px;
}

hr {
    height: 0.25em;
    padding: 0;
    margin: 24px 0;
    background-color: #e7e7e7;
    border: 0;
}

blockquote {
    padding: 0 1em;
    color: #777;
    border-left: 0.25em solid #ddd;
}

blockquote>:first-child {
    margin-top: 0;
}

blockquote>:last-child {
    margin-bottom: 0;
}

kbd {
    display: inline-block;
    padding: 3px 5px;
    font-size: 11px;
    line-height: 10px;
    color: #555;
    vertical-align: middle;
    background-color: #fcfcfc;
    border: solid 1px #ccc;
    border-bottom-color: #bbb;
    border-radius: 3px;
    box-shadow: inset 0 -1px 0 #bbb;
}

h1, h2, h3, h4, h5, h6 {
    margin-top: 24px;
    margin-bottom: 16px;
    font-weight: 600;
    line-height: 1.25;
}

h1 .octicon-link, h2 .octicon-link, h3 .octicon-link, h4 .octicon-link, h5 .octicon-link, h6 .octicon-link {
    color: #000;
    vertical-align: middle;
    visibility: hidden;
}

h1:hover .anchor, h2:hover .anchor, h3:hover .anchor, h4:hover .anchor, h5:hover .anchor, h6:hover .anchor {
    text-decoration: none;
}

h1:hover .anchor .octicon-link, h2:hover .anchor .octicon-link, h3:hover .anchor .octicon-link, h4:hover .anchor .octicon-link, h5:hover .anchor .octicon-link, h6:hover .anchor .octicon-link {
    visibility: visible;
}

h1 {
    padding-bottom: 0.3em;
    font-size: 2em;
    border-bottom: 1px solid #eee;
}

h2 {
    padding-bottom: 0.3em;
    font-size: 1.5em;
    border-bottom: 1px solid #eee;
}

h3 {
    font-size: 1.25em;
}

h4 {
    font-size: 1em;
}

h5 {
    font-size: 0.875em;
}

h6 {
    font-size: 0.85em;
    color: #777;
}

ul, ol {
    padding-left: 2em;
}

ul ul, ul ol, ol ol, ol ul {
    margin-top: 0;
    margin-bottom: 0;
}

li>p {
    margin-top: 16px;
}

li+li {
    margin-top: 0.25em;
}

dl {
    padding: 0;
}

dl dt {
    padding: 0;
    margin-top: 16px;
    font-size: 1em;
    font-style: italic;
    font-weight: bold;
}

dl dd {
    padding: 0 16px;
    margin-bottom: 16px;
}

table {
    display: block;
    width: 100%;
    overflow: auto;
    word-break: normal;
    word-break: keep-all;
}

table th {
    font-weight: bold;
}

table th, table td {
    padding: 6px 13px;
    border: 1px solid #ddd;
}

table tr {
    background-color: #fff;
    border-top: 1px solid #ccc;
}

table tr:nth-child(2n) {
    background-color: #f8f8f8;
}

img {
    max-width: 100%;
    box-sizing: content-box;
    background-color: #fff;
}

code {
    padding: 0;
    padding-top: 0.2em;
    padding-bottom: 0.2em;
    margin: 0;
    font-size: 85%;
    background-color: rgba(0, 0, 0, 0.04);
    border-radius: 3px;
}

code::before, code::after {
    letter-spacing: -0.2em;
    content: "\00a0";
}

pre {
    word-wrap: normal;
}

pre>code {
    padding: 0;
    margin: 0;
    font-size: 100%;
    word-break: normal;
    white-space: pre;
    background: transparent;
    border: 0;
}

.highlight {
    margin-bottom: 16px;
}

.highlight pre {
    margin-bottom: 0;
    word-break: normal;
}

.highlight pre, pre {
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border-radius: 3px;
}

pre code {
    display: inline;
    max-width: auto;
    padding: 0;
    margin: 0;
    overflow: visible;
    line-height: inherit;
    word-wrap: normal;
    background-color: transparent;
    border: 0;
}

pre code::before, pre code::after {
    content: normal;
}

.pl-0 {
    padding-left: 0 !important;
}

.pl-1 {
    padding-left: 3px !important;
}

.pl-2 {
    padding-left: 6px !important;
}

.pl-3 {
    padding-left: 12px !important;
}

.pl-4 {
    padding-left: 24px !important;
}

.pl-5 {
    padding-left: 36px !important;
}

.pl-6 {
    padding-left: 48px !important;
}

.full-commit .btn-outline:not(:disabled):hover {
    color: #4078c0;
    border: 1px solid #4078c0;
}

kbd {
    display: inline-block;
    padding: 3px 5px;
    font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
    line-height: 10px;
    color: #555;
    vertical-align: middle;
    background-color: #fcfcfc;
    border: solid 1px #ccc;
    border-bottom-color: #bbb;
    border-radius: 3px;
    box-shadow: inset 0 -1px 0 #bbb;
}

:checked+.radio-label {
    position: relative;
    z-index: 1;
    border-color: #4078c0;
}

.task-list-item {
    list-style-type: none;
}

.task-list-item+.task-list-item {
    margin-top: 3px;
}

.task-list-item input {
    margin: 0 0.2em 0.25em -1.6em;
    vertical-align: middle;
}

hr {
    border-bottom-color: #eee;
}
</style>
        
        
            <style>/*

Original highlight.js style (c) Ivan Sagalaev <maniac@softwaremaniacs.org>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #F0F0F0;
}


/* Base color: saturation 0; */

.hljs,
.hljs-subst {
  color: #444;
}

.hljs-comment {
  color: #888888;
}

.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-meta-keyword,
.hljs-doctag,
.hljs-name {
  font-weight: bold;
}


/* User color: hue: 0 */

.hljs-type,
.hljs-string,
.hljs-number,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #880000;
}

.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold;
}

.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #BC6060;
}


/* Language color: hue: 90; */

.hljs-literal {
  color: #78A960;
}

.hljs-built_in,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #397300;
}


/* Meta color: hue: 200 */

.hljs-meta {
  color: #1f7199;
}

.hljs-meta-string {
  color: #4d99bf;
}


/* Misc effects */

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}
</style>
            <script>/*
Syntax highlighting with language autodetection.
https://highlightjs.org/
*/

(function(factory) {

  // Find the global object for export to both the browser and web workers.
  var globalObject = typeof window === 'object' && window ||
                     typeof self === 'object' && self;

  // Setup highlight.js for different environments. First is Node.js or
  // CommonJS.
  if(typeof exports !== 'undefined') {
    factory(exports);
  } else if(globalObject) {
    // Export hljs globally even when using AMD for cases when this script
    // is loaded with others that may still expect a global hljs.
    globalObject.hljs = factory({});

    // Finally register the global hljs with AMD.
    if(typeof define === 'function' && define.amd) {
      define([], function() {
        return globalObject.hljs;
      });
    }
  }

}(function(hljs) {
  // Convenience variables for build-in objects
  var ArrayProto = [],
      objectKeys = Object.keys;

  // Global internal variables used within the highlight.js library.
  var languages = {},
      aliases   = {};

  // Regular expressions used throughout the highlight.js library.
  var noHighlightRe    = /^(no-?highlight|plain|text)$/i,
      languagePrefixRe = /\blang(?:uage)?-([\w-]+)\b/i,
      fixMarkupRe      = /((^(<[^>]+>|\t|)+|(?:\n)))/gm;

  var spanEndTag = '</span>';

  // Global options used when within external APIs. This is modified when
  // calling the `hljs.configure` function.
  var options = {
    classPrefix: 'hljs-',
    tabReplace: null,
    useBR: false,
    languages: undefined
  };

  // Object map that is used to escape some common HTML characters.
  var escapeRegexMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;'
  };

  /* Utility functions */

  function escape(value) {
    return value.replace(/[&<>]/gm, function(character) {
      return escapeRegexMap[character];
    });
  }

  function tag(node) {
    return node.nodeName.toLowerCase();
  }

  function testRe(re, lexeme) {
    var match = re && re.exec(lexeme);
    return match && match.index === 0;
  }

  function isNotHighlighted(language) {
    return noHighlightRe.test(language);
  }

  function blockLanguage(block) {
    var i, match, length, _class;
    var classes = block.className + ' ';

    classes += block.parentNode ? block.parentNode.className : '';

    // language-* takes precedence over non-prefixed class names.
    match = languagePrefixRe.exec(classes);
    if (match) {
      return getLanguage(match[1]) ? match[1] : 'no-highlight';
    }

    classes = classes.split(/\s+/);

    for (i = 0, length = classes.length; i < length; i++) {
      _class = classes[i]

      if (isNotHighlighted(_class) || getLanguage(_class)) {
        return _class;
      }
    }
  }

  function inherit(parent, obj) {
    var key;
    var result = {};

    for (key in parent)
      result[key] = parent[key];
    if (obj)
      for (key in obj)
        result[key] = obj[key];
    return result;
  }

  /* Stream merging */

  function nodeStream(node) {
    var result = [];
    (function _nodeStream(node, offset) {
      for (var child = node.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === 3)
          offset += child.nodeValue.length;
        else if (child.nodeType === 1) {
          result.push({
            event: 'start',
            offset: offset,
            node: child
          });
          offset = _nodeStream(child, offset);
          // Prevent void elements from having an end tag that would actually
          // double them in the output. There are more void elements in HTML
          // but we list only those realistically expected in code display.
          if (!tag(child).match(/br|hr|img|input/)) {
            result.push({
              event: 'stop',
              offset: offset,
              node: child
            });
          }
        }
      }
      return offset;
    })(node, 0);
    return result;
  }

  function mergeStreams(original, highlighted, value) {
    var processed = 0;
    var result = '';
    var nodeStack = [];

    function selectStream() {
      if (!original.length || !highlighted.length) {
        return original.length ? original : highlighted;
      }
      if (original[0].offset !== highlighted[0].offset) {
        return (original[0].offset < highlighted[0].offset) ? original : highlighted;
      }

      /*
      To avoid starting the stream just before it should stop the order is
      ensured that original always starts first and closes last:

      if (event1 == 'start' && event2 == 'start')
        return original;
      if (event1 == 'start' && event2 == 'stop')
        return highlighted;
      if (event1 == 'stop' && event2 == 'start')
        return original;
      if (event1 == 'stop' && event2 == 'stop')
        return highlighted;

      ... which is collapsed to:
      */
      return highlighted[0].event === 'start' ? original : highlighted;
    }

    function open(node) {
      function attr_str(a) {return ' ' + a.nodeName + '="' + escape(a.value) + '"';}
      result += '<' + tag(node) + ArrayProto.map.call(node.attributes, attr_str).join('') + '>';
    }

    function close(node) {
      result += '</' + tag(node) + '>';
    }

    function render(event) {
      (event.event === 'start' ? open : close)(event.node);
    }

    while (original.length || highlighted.length) {
      var stream = selectStream();
      result += escape(value.substr(processed, stream[0].offset - processed));
      processed = stream[0].offset;
      if (stream === original) {
        /*
        On any opening or closing tag of the original markup we first close
        the entire highlighted node stack, then render the original tag along
        with all the following original tags at the same offset and then
        reopen all the tags on the highlighted stack.
        */
        nodeStack.reverse().forEach(close);
        do {
          render(stream.splice(0, 1)[0]);
          stream = selectStream();
        } while (stream === original && stream.length && stream[0].offset === processed);
        nodeStack.reverse().forEach(open);
      } else {
        if (stream[0].event === 'start') {
          nodeStack.push(stream[0].node);
        } else {
          nodeStack.pop();
        }
        render(stream.splice(0, 1)[0]);
      }
    }
    return result + escape(value.substr(processed));
  }

  /* Initialization */

  function compileLanguage(language) {

    function reStr(re) {
        return (re && re.source) || re;
    }

    function langRe(value, global) {
      return new RegExp(
        reStr(value),
        'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')
      );
    }

    function compileMode(mode, parent) {
      if (mode.compiled)
        return;
      mode.compiled = true;

      mode.keywords = mode.keywords || mode.beginKeywords;
      if (mode.keywords) {
        var compiled_keywords = {};

        var flatten = function(className, str) {
          if (language.case_insensitive) {
            str = str.toLowerCase();
          }
          str.split(' ').forEach(function(kw) {
            var pair = kw.split('|');
            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];
          });
        };

        if (typeof mode.keywords === 'string') { // string
          flatten('keyword', mode.keywords);
        } else {
          objectKeys(mode.keywords).forEach(function (className) {
            flatten(className, mode.keywords[className]);
          });
        }
        mode.keywords = compiled_keywords;
      }
      mode.lexemesRe = langRe(mode.lexemes || /\w+/, true);

      if (parent) {
        if (mode.beginKeywords) {
          mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\b';
        }
        if (!mode.begin)
          mode.begin = /\B|\b/;
        mode.beginRe = langRe(mode.begin);
        if (!mode.end && !mode.endsWithParent)
          mode.end = /\B|\b/;
        if (mode.end)
          mode.endRe = langRe(mode.end);
        mode.terminator_end = reStr(mode.end) || '';
        if (mode.endsWithParent && parent.terminator_end)
          mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;
      }
      if (mode.illegal)
        mode.illegalRe = langRe(mode.illegal);
      if (mode.relevance == null)
        mode.relevance = 1;
      if (!mode.contains) {
        mode.contains = [];
      }
      var expanded_contains = [];
      mode.contains.forEach(function(c) {
        if (c.variants) {
          c.variants.forEach(function(v) {expanded_contains.push(inherit(c, v));});
        } else {
          expanded_contains.push(c === 'self' ? mode : c);
        }
      });
      mode.contains = expanded_contains;
      mode.contains.forEach(function(c) {compileMode(c, mode);});

      if (mode.starts) {
        compileMode(mode.starts, parent);
      }

      var terminators =
        mode.contains.map(function(c) {
          return c.beginKeywords ? '\\.?(' + c.begin + ')\\.?' : c.begin;
        })
        .concat([mode.terminator_end, mode.illegal])
        .map(reStr)
        .filter(Boolean);
      mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : {exec: function(/*s*/) {return null;}};
    }

    compileMode(language);
  }

  /*
  Core highlighting function. Accepts a language name, or an alias, and a
  string with the code to highlight. Returns an object with the following
  properties:

  - relevance (int)
  - value (an HTML string with highlighting markup)

  */
  function highlight(name, value, ignore_illegals, continuation) {

    function subMode(lexeme, mode) {
      var i, length;

      for (i = 0, length = mode.contains.length; i < length; i++) {
        if (testRe(mode.contains[i].beginRe, lexeme)) {
          return mode.contains[i];
        }
      }
    }

    function endOfMode(mode, lexeme) {
      if (testRe(mode.endRe, lexeme)) {
        while (mode.endsParent && mode.parent) {
          mode = mode.parent;
        }
        return mode;
      }
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, lexeme);
      }
    }

    function isIllegal(lexeme, mode) {
      return !ignore_illegals && testRe(mode.illegalRe, lexeme);
    }

    function keywordMatch(mode, match) {
      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];
      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];
    }

    function buildSpan(classname, insideSpan, leaveOpen, noPrefix) {
      var classPrefix = noPrefix ? '' : options.classPrefix,
          openSpan    = '<span class="' + classPrefix,
          closeSpan   = leaveOpen ? '' : spanEndTag

      openSpan += classname + '">';

      return openSpan + insideSpan + closeSpan;
    }

    function processKeywords() {
      var keyword_match, last_index, match, result;

      if (!top.keywords)
        return escape(mode_buffer);

      result = '';
      last_index = 0;
      top.lexemesRe.lastIndex = 0;
      match = top.lexemesRe.exec(mode_buffer);

      while (match) {
        result += escape(mode_buffer.substr(last_index, match.index - last_index));
        keyword_match = keywordMatch(top, match);
        if (keyword_match) {
          relevance += keyword_match[1];
          result += buildSpan(keyword_match[0], escape(match[0]));
        } else {
          result += escape(match[0]);
        }
        last_index = top.lexemesRe.lastIndex;
        match = top.lexemesRe.exec(mode_buffer);
      }
      return result + escape(mode_buffer.substr(last_index));
    }

    function processSubLanguage() {
      var explicit = typeof top.subLanguage === 'string';
      if (explicit && !languages[top.subLanguage]) {
        return escape(mode_buffer);
      }

      var result = explicit ?
                   highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) :
                   highlightAuto(mode_buffer, top.subLanguage.length ? top.subLanguage : undefined);

      // Counting embedded language score towards the host language may be disabled
      // with zeroing the containing mode relevance. Usecase in point is Markdown that
      // allows XML everywhere and makes every XML snippet to have a much larger Markdown
      // score.
      if (top.relevance > 0) {
        relevance += result.relevance;
      }
      if (explicit) {
        continuations[top.subLanguage] = result.top;
      }
      return buildSpan(result.language, result.value, false, true);
    }

    function processBuffer() {
      result += (top.subLanguage != null ? processSubLanguage() : processKeywords());
      mode_buffer = '';
    }

    function startNewMode(mode) {
      result += mode.className? buildSpan(mode.className, '', true): '';
      top = Object.create(mode, {parent: {value: top}});
    }

    function processLexeme(buffer, lexeme) {

      mode_buffer += buffer;

      if (lexeme == null) {
        processBuffer();
        return 0;
      }

      var new_mode = subMode(lexeme, top);
      if (new_mode) {
        if (new_mode.skip) {
          mode_buffer += lexeme;
        } else {
          if (new_mode.excludeBegin) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (!new_mode.returnBegin && !new_mode.excludeBegin) {
            mode_buffer = lexeme;
          }
        }
        startNewMode(new_mode, lexeme);
        return new_mode.returnBegin ? 0 : lexeme.length;
      }

      var end_mode = endOfMode(top, lexeme);
      if (end_mode) {
        var origin = top;
        if (origin.skip) {
          mode_buffer += lexeme;
        } else {
          if (!(origin.returnEnd || origin.excludeEnd)) {
            mode_buffer += lexeme;
          }
          processBuffer();
          if (origin.excludeEnd) {
            mode_buffer = lexeme;
          }
        }
        do {
          if (top.className) {
            result += spanEndTag;
          }
          if (!top.skip) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== end_mode.parent);
        if (end_mode.starts) {
          startNewMode(end_mode.starts, '');
        }
        return origin.returnEnd ? 0 : lexeme.length;
      }

      if (isIllegal(lexeme, top))
        throw new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');

      /*
      Parser should not reach this point as all types of lexemes should be caught
      earlier, but if it does due to some bug make sure it advances at least one
      character forward to prevent infinite looping.
      */
      mode_buffer += lexeme;
      return lexeme.length || 1;
    }

    var language = getLanguage(name);
    if (!language) {
      throw new Error('Unknown language: "' + name + '"');
    }

    compileLanguage(language);
    var top = continuation || language;
    var continuations = {}; // keep continuations for sub-languages
    var result = '', current;
    for(current = top; current !== language; current = current.parent) {
      if (current.className) {
        result = buildSpan(current.className, '', true) + result;
      }
    }
    var mode_buffer = '';
    var relevance = 0;
    try {
      var match, count, index = 0;
      while (true) {
        top.terminators.lastIndex = index;
        match = top.terminators.exec(value);
        if (!match)
          break;
        count = processLexeme(value.substr(index, match.index - index), match[0]);
        index = match.index + count;
      }
      processLexeme(value.substr(index));
      for(current = top; current.parent; current = current.parent) { // close dangling modes
        if (current.className) {
          result += spanEndTag;
        }
      }
      return {
        relevance: relevance,
        value: result,
        language: name,
        top: top
      };
    } catch (e) {
      if (e.message && e.message.indexOf('Illegal') !== -1) {
        return {
          relevance: 0,
          value: escape(value)
        };
      } else {
        throw e;
      }
    }
  }

  /*
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:

  - language (detected language)
  - relevance (int)
  - value (an HTML string with highlighting markup)
  - second_best (object with the same structure for second-best heuristically
    detected language, may be absent)

  */
  function highlightAuto(text, languageSubset) {
    languageSubset = languageSubset || options.languages || objectKeys(languages);
    var result = {
      relevance: 0,
      value: escape(text)
    };
    var second_best = result;
    languageSubset.filter(getLanguage).forEach(function(name) {
      var current = highlight(name, text, false);
      current.language = name;
      if (current.relevance > second_best.relevance) {
        second_best = current;
      }
      if (current.relevance > result.relevance) {
        second_best = result;
        result = current;
      }
    });
    if (second_best.language) {
      result.second_best = second_best;
    }
    return result;
  }

  /*
  Post-processing of the highlighted markup:

  - replace TABs with something more useful
  - replace real line-breaks with '<br>' for non-pre containers

  */
  function fixMarkup(value) {
    return !(options.tabReplace || options.useBR)
      ? value
      : value.replace(fixMarkupRe, function(match, p1) {
          if (options.useBR && match === '\n') {
            return '<br>';
          } else if (options.tabReplace) {
            return p1.replace(/\t/g, options.tabReplace);
          }
      });
  }

  function buildClassName(prevClassName, currentLang, resultLang) {
    var language = currentLang ? aliases[currentLang] : resultLang,
        result   = [prevClassName.trim()];

    if (!prevClassName.match(/\bhljs\b/)) {
      result.push('hljs');
    }

    if (prevClassName.indexOf(language) === -1) {
      result.push(language);
    }

    return result.join(' ').trim();
  }

  /*
  Applies highlighting to a DOM node containing code. Accepts a DOM node and
  two optional parameters for fixMarkup.
  */
  function highlightBlock(block) {
    var node, originalStream, result, resultNode, text;
    var language = blockLanguage(block);

    if (isNotHighlighted(language))
        return;

    if (options.useBR) {
      node = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      node.innerHTML = block.innerHTML.replace(/\n/g, '').replace(/<br[ \/]*>/g, '\n');
    } else {
      node = block;
    }
    text = node.textContent;
    result = language ? highlight(language, text, true) : highlightAuto(text);

    originalStream = nodeStream(node);
    if (originalStream.length) {
      resultNode = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
      resultNode.innerHTML = result.value;
      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
    }
    result.value = fixMarkup(result.value);

    block.innerHTML = result.value;
    block.className = buildClassName(block.className, language, result.language);
    block.result = {
      language: result.language,
      re: result.relevance
    };
    if (result.second_best) {
      block.second_best = {
        language: result.second_best.language,
        re: result.second_best.relevance
      };
    }
  }

  /*
  Updates highlight.js global options with values passed in the form of an object.
  */
  function configure(user_options) {
    options = inherit(options, user_options);
  }

  /*
  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
  */
  function initHighlighting() {
    if (initHighlighting.called)
      return;
    initHighlighting.called = true;

    var blocks = document.querySelectorAll('pre code');
    ArrayProto.forEach.call(blocks, highlightBlock);
  }

  /*
  Attaches highlighting to the page load event.
  */
  function initHighlightingOnLoad() {
    addEventListener('DOMContentLoaded', initHighlighting, false);
    addEventListener('load', initHighlighting, false);
  }

  function registerLanguage(name, language) {
    var lang = languages[name] = language(hljs);
    if (lang.aliases) {
      lang.aliases.forEach(function(alias) {aliases[alias] = name;});
    }
  }

  function listLanguages() {
    return objectKeys(languages);
  }

  function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
  }

  /* Interface definition */

  hljs.highlight = highlight;
  hljs.highlightAuto = highlightAuto;
  hljs.fixMarkup = fixMarkup;
  hljs.highlightBlock = highlightBlock;
  hljs.configure = configure;
  hljs.initHighlighting = initHighlighting;
  hljs.initHighlightingOnLoad = initHighlightingOnLoad;
  hljs.registerLanguage = registerLanguage;
  hljs.listLanguages = listLanguages;
  hljs.getLanguage = getLanguage;
  hljs.inherit = inherit;

  // Common regexps
  hljs.IDENT_RE = '[a-zA-Z]\\w*';
  hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
  hljs.NUMBER_RE = '\\b\\d+(\\.\\d+)?';
  hljs.C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
  hljs.BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
  hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

  // Common modes
  hljs.BACKSLASH_ESCAPE = {
    begin: '\\\\[\\s\\S]', relevance: 0
  };
  hljs.APOS_STRING_MODE = {
    className: 'string',
    begin: '\'', end: '\'',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.QUOTE_STRING_MODE = {
    className: 'string',
    begin: '"', end: '"',
    illegal: '\\n',
    contains: [hljs.BACKSLASH_ESCAPE]
  };
  hljs.PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\b/
  };
  hljs.COMMENT = function (begin, end, inherits) {
    var mode = hljs.inherit(
      {
        className: 'comment',
        begin: begin, end: end,
        contains: []
      },
      inherits || {}
    );
    mode.contains.push(hljs.PHRASAL_WORDS_MODE);
    mode.contains.push({
      className: 'doctag',
      begin: '(?:TODO|FIXME|NOTE|BUG|XXX):',
      relevance: 0
    });
    return mode;
  };
  hljs.C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$');
  hljs.C_BLOCK_COMMENT_MODE = hljs.COMMENT('/\\*', '\\*/');
  hljs.HASH_COMMENT_MODE = hljs.COMMENT('#', '$');
  hljs.NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE,
    relevance: 0
  };
  hljs.C_NUMBER_MODE = {
    className: 'number',
    begin: hljs.C_NUMBER_RE,
    relevance: 0
  };
  hljs.BINARY_NUMBER_MODE = {
    className: 'number',
    begin: hljs.BINARY_NUMBER_RE,
    relevance: 0
  };
  hljs.CSS_NUMBER_MODE = {
    className: 'number',
    begin: hljs.NUMBER_RE + '(' +
      '%|em|ex|ch|rem'  +
      '|vw|vh|vmin|vmax' +
      '|cm|mm|in|pt|pc|px' +
      '|deg|grad|rad|turn' +
      '|s|ms' +
      '|Hz|kHz' +
      '|dpi|dpcm|dppx' +
      ')?',
    relevance: 0
  };
  hljs.REGEXP_MODE = {
    className: 'regexp',
    begin: /\//, end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      hljs.BACKSLASH_ESCAPE,
      {
        begin: /\[/, end: /\]/,
        relevance: 0,
        contains: [hljs.BACKSLASH_ESCAPE]
      }
    ]
  };
  hljs.TITLE_MODE = {
    className: 'title',
    begin: hljs.IDENT_RE,
    relevance: 0
  };
  hljs.UNDERSCORE_TITLE_MODE = {
    className: 'title',
    begin: hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  hljs.METHOD_GUARD = {
    // excludes method names from keyword processing
    begin: '\\.\\s*' + hljs.UNDERSCORE_IDENT_RE,
    relevance: 0
  };

  return hljs;
}));
</script>
        

        

        
    </head>
    <body>
        <div id="pageHeader"></div>
        <h1 id="yamp">Yamp</h1>
<p><em>by @angrykoala</em></p>
<p><a href="https://badge.fury.io/js/yamp"><img src="https://badge.fury.io/js/yamp.svg" alt="npm version"></a> 
<a href="https://travis-ci.org/angrykoala/yamp"><img src="https://travis-ci.org/angrykoala/yamp.svg?branch=master" alt="Build Status"></a> 
<a href="https://codecov.io/gh/angrykoala/yamp"><img src="https://codecov.io/gh/angrykoala/yamp/branch/master/graph/badge.svg" alt="codecov"></a>
<a href="https://gemnasium.com/github.com/angrykoala/yamp"><img src="https://gemnasium.com/badges/github.com/angrykoala/yamp.svg" alt="Dependency Status"></a>       </p>
<blockquote>
<p>Yet Another Markdown Parser</p>
</blockquote>
<p>The aim of this package is to provide an easy-to-use toolbox for markdown-related task including Html &amp; Pdf conversion.</p>
<ul>
<li><strong>GitHub:</strong> <a href="https://github.com/angrykoala/yamp">https://github.com/angrykoala/yamp</a></li>
<li><strong>Npm:</strong> <a href="https://www.npmjs.com/package/yamp">https://www.npmjs.com/package/yamp</a></li>
</ul>
<h2 id="features">Features</h2>
<ul>
<li>HTML conversion</li>
<li>PDF conversion</li>
<li>Code highlight support</li>
<li>Github-style and academic output</li>
<li>API to use <em>yamp</em> programmatically</li>
<li>Custom styles</li>
<li>CSS-embedded HTML (just open it offline in any browser)</li>
<li>HTML tags support (for PDF output too)</li>
<li>Include other files in your markdown</li>
<li><a href="https://remarkjs.com/">HTML presentations</a></li>
<li>Front Matter metadata</li>
<li>Custom <a href="https://github.com/angrykoala/xejs">xejs-based</a> tags (<code>{{}}</code>)</li>
<li>Koalafied</li>
</ul>
<h3 id="upcoming-features">Upcoming features</h3>
<ul>
<li>Custom templates</li>
<li>Client-side web support (browserify)</li>
</ul>
<blockquote>
<p>Check the <a href="https://github.com/angrykoala/yamp/milestones?direction=desc&amp;sort=completeness&amp;state=open">project roadmap</a> and our cute <a href="https://github.com/angrykoala/yamp/projects/1">kanban board</a></p>
</blockquote>
<h2 id="installation">Installation</h2>
<p>To use <em>yamp</em> cli, install it globally using <strong>npm</strong>:</p>
<pre><code>npm <span class="hljs-keyword">install</span> -g yamp
</code></pre><p>If you want to use the API instead, install it locally:</p>
<pre><code>npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save yamp</span>
</code></pre><p>then, include yamp in your javascript:</p>
<pre><code class="lang-js"><span class="hljs-attribute">var yamp</span> = require(<span class="hljs-string">'yamp'</span>);
</code></pre>
<h2 id="usage">Usage</h2>
<p>To create a <code>.pdf</code> file from your <em>markdown</em> file, simply type:</p>
<pre><code>yamp &lt;<span class="hljs-built_in">file</span>.md&gt;
</code></pre><p>For example:</p>
<pre><code><span class="hljs-selector-tag">yamp</span> <span class="hljs-selector-tag">README</span><span class="hljs-selector-class">.md</span>
</code></pre><p>Will generate <code>readme.pdf</code>.</p>
<h3 id="options">Options</h3>
<ul>
<li><code>-h</code>, <code>--help</code> to display a basic usage information</li>
<li><code>-V</code>, <code>--version</code> to display <em>yamp</em> version installed</li>
<li><code>-o</code>, <code>--output &lt;file&gt;</code> output filename (without extension) e.g. <code>yamp my_file.md -o final_name</code></li>
<li><code>--pdf</code> to generate a pdf (default)</li>
<li><code>--html</code>to generate html</li>
<li><code>--remark</code>to generate a html presentation using <a href="https://remarkjs.com">remark</a></li>
<li><code>-t</code>, <code>--title [value]</code> to add a custom title to Html pages</li>
<li><code>--style &lt;file&gt;</code> to set change the css style (supports the provided styles and custom styles)<ul>
<li>Option not suported along with <code>--no-style</code></li>
</ul>
</li>
<li><code>--no-style</code> to disable CSS styling<ul>
<li>Option not supported along with <code>--style &lt;file&gt;</code></li>
</ul>
</li>
<li><code>--list-styles</code> will list all the styles provided by yamp<ul>
<li>These styles will be supported by <code>--style</code> option</li>
</ul>
</li>
<li><code>--minify</code> to minify Html output</li>
<li><code>--no-tags</code> to disable custom Yamp tags</li>
<li><code>--no-highlight</code> to disable code <a href="https://highlightjs.org">highlight</a></li>
<li><code>--no-front-matter</code> to disable front-matter metadata</li>
<li><code>-k</code>, <code>--koala</code> to koalify your outputs</li>
</ul>
<p>To generate pdf and html with default styling and options:</p>
<pre><code><span class="hljs-comment">yamp</span> <span class="hljs-comment">myFile</span><span class="hljs-string">.</span><span class="hljs-comment">md</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">pdf</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">html</span>
</code></pre><blockquote>
<p>The <code>--no-highlight</code> and <code>--no-style</code> options will greatly reduce your Html and Pdf outputs</p>
</blockquote>
<h2 id="yamp-tags">Yamp tags</h2>
<p><em>Yamp</em> supports extra tags in your markdown files. Currently using <a href="https://github.com/angrykoala/xejs">xejs</a> templates. All tags are written between double braces <code>{{ ... }}</code> and are not case-sensitive</p>
<ul>
<li><code>include [file.md]</code>: Includes the given text file (markdown or not), the tags on the included file will also be parsed, allowing nested file structure.</li>
<li><code>date</code>: Will write the current date (at the moment of rendering).</li>
<li><code>page break</code>: Will force a page break in pdf output.</li>
<li><code>yamp version</code>: Will display the yamp version used to render the document.</li>
</ul>
<blockquote>
<p> Starting a tag with <code>{{#</code> will create a comment tag that will not be rendered into the final file</p>
</blockquote>
<h2 id="yamp-styles">Yamp styles</h2>
<p><em>Yamp</em> provides several styles for your document (supported for html and pdf outputs).</p>
<ul>
<li><code>github.css</code> Default style, will look similar to <strong>Github</strong> style</li>
<li><code>acm-sig.css</code> Academic style based on ACM SIG templates</li>
</ul>
<p>You can select any of these styles with the option <code>--style [style.css]</code>, the same option will enable you to use your own files instead <code>--style [myfolder/mystyle.css]</code></p>
<blockquote>
<p>You can always check the styles with the option <code>--list-styles</code></p>
</blockquote>
<h2 id="api">API</h2>
<p>Include <em>yamp</em> in your javascript with:</p>
<pre><code class="lang-js"><span class="hljs-attribute">var yamp</span> = require(<span class="hljs-string">'yamp'</span>);
</code></pre>
<p>You&#39;ll have access to different <em>renderers</em> to process your files:</p>
<ul>
<li><code>yamp.renderers.html</code> to process a markdown file into an full Html page</li>
<li><code>yamp.renderers.pdf</code> to process a markdown into a pdf</li>
</ul>
<p>To use a renderer:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> myRenderer = <span class="hljs-keyword">new</span> renderers.pdf(options);
renderer.renderFile(myFile, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Error while rendering: "</span>+err);
    <span class="hljs-keyword">else</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Rendering was successful"</span>);
});
</code></pre>
<h3 id="options">Options</h3>
<p>The options accepted by the default renderers are:</p>
<ul>
<li><strong>outputFilename</strong>: name of the output filename (without extension), will default to the input filename</li>
<li><strong>highlight</strong>: (<em>true</em>) indicates if code blocks should be highlighted</li>
<li><strong>style</strong>: (<em>true</em>) indicates if default style should be used or no style at all. If a filename is passed, it will use it as custom css style</li>
<li><strong>minify</strong>: (<em>false</em>) whether the Html output should be minified or not</li>
<li><strong>title</strong>: Custom title for the Html page</li>
<li><strong>tags</strong>: (<em>true</em>) whether to parse yamp tags or not (<code>{{ ... }}</code>) </li>
<li><strong>koala</strong>: (<em>false</em>) true to koalify your outputs</li>
</ul>
<h3 id="creating-new-renderers">Creating new renderers</h3>
<p>If you need a custom renderer, instead of using one of the defaults you can extend directly from <strong>Renderer</strong> class or any of the default renderers:</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCustomRenderer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">yamp</span>.<span class="hljs-title">Renderer</span> </span>{
    constructor(options) {
        <span class="hljs-keyword">super</span>(options, <span class="hljs-string">"default.ejs"</span>, yamp.parsers.md2Html);
        <span class="hljs-keyword">this</span>.output=<span class="hljs-string">"html"</span>; <span class="hljs-comment">//desired output extension</span>
    }

    beforeLoad(filename){
        <span class="hljs-comment">//Modify filename or this.fileLoader before loading it</span>
    }


    beforeRender(templateOptions) {
        <span class="hljs-comment">// Modify the data passed to the template before rendering, including title, content and options</span>
    }

    afterRender(content) {
        <span class="hljs-comment">// Modify template result (Html)</span>
    }

    fileOutput(content,done) {
        <span class="hljs-comment">// Write file (preferably to this.options.outputFilename) in the desired format using a parser</span>
    }
}
</code></pre>
<p><strong>Custom parser:</strong> It is possible to use a custom parser from markdown to Html instead of the built-in <em>yamp.parsers.md2html</em>, the parser must be a function of the type <code>function(originalString,options,callback)</code> that will translate from <code>originalString</code> (markdown) to html, calling the <code>callback(err,res)</code> afterwards.</p>
<p>If, instead of extending from <code>yamp.Renderer</code> you are extending from one of the default renderers, you should only re-implement the methods you need, and usually you should call <code>super().methodName</code> to maintain its basic functionality.</p>
<h2 id="development-instructions">Development Instructions</h2>
<p>To contribute to <strong>yamp</strong> you should clone the official repository <a href="https://github.com/angrykoala/yamp">https://github.com/angrykoala/yamp</a> or your own <em>fork</em> with <code>git</code>.</p>
<p>You can also download it from <a href="https://github.com">GitHub</a> clicking <a href="https://github.com/angrykoala/yamp/archive/master.zip">here</a></p>
<ul>
<li>To install execute <code>npm install</code> in the downloaded/cloned folder</li>
<li>To test, execute <code>npm test</code><ul>
<li>The tests will also run <em>jshint</em></li>
</ul>
</li>
<li>To execute the CLI, execute <code>npm start -- &lt;file&gt; [options]</code></li>
<li>To install your local version globally, execute <code>npm install -g .</code> on the project folder</li>
<li>To generate documentation (with installed version of <em>yamp</em>) execute <code>npm run docs</code></li>
</ul>
<blockquote>
<p>It is strongly recommended to install the npm repository version instead of your local copy</p>
</blockquote>
<h2 id="contributors">Contributors</h2>
<p>If you want to contribute to yamp please:   </p>
<ol>
<li>Read CONTRIBUTING.md</li>
<li>Fork from <a href="https://github.com/angrykoala/yamp/tree/dev">dev branch</a></li>
<li>Make sure tests passes before pull request</li>
<li>Check the opened and closed issues before creating one</li>
</ol>
<p>Thanks for your help!</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<ul>
<li><a href="https://github.com/chjj/marked">Marked</a> as markdown parser</li>
<li><a href="https://github.com/sindresorhus/github-markdown-css">Github-markdown.css</a> as default style</li>
<li><a href="https://highlightjs.org">Highlight.js</a> for code highlighting</li>
<li><a href="https://github.com/marcbachmann/node-html-pdf">html-pdf</a> for pdf generation</li>
<li><a href="https://remarkjs.com">remark</a> for html slides output</li>
<li><a href="https://github.com/thomaspark/pubcss">pubcss</a> for academic output style</li>
</ul>
<blockquote>
<p>YAMP is developed under GNU GPL-3 license by @angrykoala</p>
</blockquote>

    </body>
</html>
